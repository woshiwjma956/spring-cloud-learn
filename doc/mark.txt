SpringCloud,SpringBoot 选型官网介绍参考网址: http://start.spring.io/actuator/info

修改IDEA 配置
IDEA setting -->Edit --> File Types --> ignore files and folders

IDEA run dashboard
可以通过修改idea的workspace.xml的方式来快速打开Run Dashboard窗口
打开workspace.xml文件之后，找到component为RunDashboard的节点处，然后在component标签里添加
<option name="configurationTypes">
      <set>
        <option value="SpringBootApplicationConfigurationType" />
      </set>
</option>
参考 https://jingyan.baidu.com/article/ce4366495a1df73773afd3d3.html

Eureka的自我保护机制
Eureka的自我保护模式主要用于一组客户端和EurekaServer之间存在网络分区场景下进行自我保护,一旦进入保护
模式 EurekaServer 将会尝试保护其服务注册表中的信息,不再删除服务注册表中的信息,也就是不会在注销任何微服务
属于CAP 中的AP 分支
Eureka 默认90S 发送一次心跳检测 如果开启自我保护机制,Eureka允许90S之后未接受到心跳,依然保留服务注册信息 分区容错性
某时刻 某微服务不可用了 Eureka不会立刻清理,依旧会对微服务信息进行保存
关闭自我保护机制
Eureka:
  server:
    # 关闭自我保护机制
    enable-self-preservation: false
    # 移除服务的时间间隔
    eviction-interval-timer-in-ms: 2000

Eureka Client端
eureka:
  instance:
    # 向Eureka Server 发送心跳的频率
    lease-renewal-interval-in-seconds: 1
    # Eureka 服务端在收到最后一次心跳后等待时间上限,超出将剔除服务
    lease-expiration-duration-in-seconds: 2


Eureka Server 配置文件模板:

server:
  port: 7002

spring:
  application:
    name: cloud-server-eureka-7002

eureka:
  instance:
    # eureka 服务端实例名称 不写默认为${spring.application.name} 大写
    appname: eureka7002.com
  client:
    # 是否向注册中心注册自己 false表示不注册
    register-with-eureka: false
    # false 表示自己端就是注册中心,职责是维护服务实例,不需要去检索服务
    fetch-registry: false
    service-url:
      defaultZone: http://eureka7001:7001/eureka/


Eureka Client配置模板

server:
  port: 8002

spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/cloud-learn?useUnicode=true&characterEncoding=utf-8&useSSL=false
    username: root
    password: admin
  application:
    # 应用名字要相同 注册到eureka才认为是同一个服务..即服务的高可用
    name: cloud-server-payment

eureka:
  instance:
    # eureka 服务端实例名称 会覆盖Spring.Application.name (默认为 Spring.Application.name 全大写)展示在eureka console中
#    appname: order
    prefer-ip-address: true
#   Eureka 	Status中展示的名称 替代主机名
    instance-id: payment8002
  client:
    #  true 将自己也注册到eureka中成为一个服务实例
    register-with-eureka: true
    # true 需要从eureka中获取服务实例
    fetch-registry: true
    service-url:
#      defaultZone: http://localhost:7001/eureka/
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka

========================================================================================

Spring Cloud 整合 Zookeeper为注册中心

Zookeeper 使用的是临时节点,在未收到心跳检测之后,在配置时间内会立刻从ZK上剔除

采坑错误
org.apache.zookeeper.KeeperException.create(KeeperException.java:103) ~[zookeeper-3.5.3-beta.jar:3.5.3-beta-8ce24f9e675cbefffb8f21a47e06b42864475a60]
Spring Cloud 使用jar中自带ZK客户端工具是3.5.3-beta 如果跟实际服务器上ZK不符则需要排除该依赖,引入对应版本的ZK
      <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-zookeeper-discovery</artifactId>
            <exclusions>
                <exclusion>
                    <artifactId>zookeeper</artifactId>
                    <groupId>org.apache.zookeeper</groupId>
                </exclusion>
            </exclusions>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper -->
        <dependency>
            <groupId>org.apache.zookeeper</groupId>
            <artifactId>zookeeper</artifactId>
            <version>3.4.6</version>
        </dependency>

配置示例
server:
  port: 80
spring:
  application:
    name: cloud-service-order-zk

  cloud:
    zookeeper:
      # 配置zk连接地址, 多个ZK 以逗号分隔
      connect-string: localhost:2181

========================================================================================
Spring Cloud 整合Consul 为注册中心

Consul 下载：https://www.consul.io/downloads.html
相关命令：consul --version：查看版本信息 consul agent -dev：运行部署consul
========================================================================================
CAP理论
组件名	语言	CAP	服务健康检查	对外暴露接口	Spring Cloud集成
Eureka	Java	AP	可配支持健康检查	HTTP	集成
Consul	GO	CP	支持健康检查	HTTP、DNS	集成
Zookeeper	Java	CP	支持健康检查	客户端	集成
========================================================================================

========================================================================================
Discovery Client

========================================================================================
Ribbon
IRule接口负载规则接口
修改Ribbon默认的轮询规则
默认的规则不能被@ComponentScan 扫描到
@RibbonClient(name="SERVICE_NAME",configuration=IRule.class)

手动实现自定义负载均衡算法
主要目的是体会轮询算法的原理和CAS 和 自旋锁的思想,实际开发中直接实现IRule下面的接口使用@RibbonClient注解修改轮询算法
CompareAndSet 返回Boolean
GetAndSet 返回之前的值
compareAndSet：如果当前值 == 预期值，则以原子方式将该值设置为给定的更新值。这里需要注意的是这个方法的返回值实际上是是否成功修改，而与之前的值无关。
getAndSet ：以原子方式设置为给定值，并返回以前的值。
1.为了测试自己的轮询算法ApplicationContextBean去掉注解@LoadBalance
2.LoadBalancer接口
结合DiscoveryClient 选择一个服务
ServiceInstance instances(List<ServiceInstance> serviceList);
3.MyLB 实现LoadBalancer接口
4.OrderController改写
使用RestTemplate去请求LoadBalancer返回的那个ServiceInstance即可
5.Test

修改默认Ribbon的轮询策略 参考https://blog.csdn.net/wo18237095579/article/details/83384134
方式一: Java配置文件方式
1.创建一个@Configuration 配置文件指定全局的轮训规则
2.保证SpringBoot启动不扫描到这个配置文件 @ComponentScan(filter={})
3.@RibbonClient(name = "order", configuration = RibbonLoadBalanceConfiguration.class)

方式二: 使用 ribbon配置文件(未测试通过)
### 针对单个服务的 Ribbon 配置
cloud-service-order:
  ribbon:
    # 基于配置文件形式的 针对单个服务的 Ribbon 负载均衡策略
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule

========================================================================================
OpenFeign

==服务调用==
@EnableFeignClients
@FeignClient(name="微服务名") 参考com.ycorn.service.PaymentServiceClient

==超时控制== 参考https://www.cnblogs.com/WaterGe/p/11687118.html
默认feign为1S
java.net.SocketTimeoutException: Read timed out 异常
1 hystrix可配置的部分
hystrix.command.default.execution.timeout.enable=true //为false则超时控制有ribbon控制，为true则hystrix超时和ribbon超时都是用，但是谁小谁生效，默认为true
hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=3000//熔断器的超时时长默认1秒，最常修改的参数
circuitBreaker.requestVolumeThreshold=20 //触发熔断的最小请求次数，默认为20
circuitBreaker.sleepWindowInMilliseconds=5000 //休眠时长，默认为5秒
circuitBreaker.errorThresholdPercentage=50 //触发熔断的失败请求最小占比，默认50%
2 ribbon的可配置部分
ribbon.ReadTimeout=1000 //处理请求的超时时间，默认为1秒
ribbon.ConnectTimeout=1000 //连接建立的超时时长，默认1秒
ribbon.MaxAutoRetries=1 //同一台实例的最大重试次数，但是不包括首次调用，默认为1次
ribbon.MaxAutoRetriesNextServer=0 //重试负载均衡其他实例的最大重试次数，不包括首次调用，默认为0次
ribbon.OkToRetryOnAllOperations=false //是否对所有操作都重试，默认false
 3 Feign的可配置部分
feign.hystrix.enabled=false //Feign是否启用断路器,默认为false
feign.client.config.default.connectTimeout=10000 //Feign的连接建立超时时间，默认为10秒
feign.client.config.default.readTimeout=60000 //Feign的请求处理超时时间，默认为60
feign.client.config.default.retryer=feign.Retryer.Default //Feign使用默认的超时配置，在该类源码中可见，默认单次请求最大时长1秒，重试5次

==日志增强==
添加配置
@Configuration
public class FeignLogConfiguration {
    @Bean
    Logger.Level feignLoggerLevel() {
        return Logger.Level.FULL;
    }
}
修改yml
# 配置feign 调用日志查看
logging:
  level:
    com.ycorn.service.PaymentServiceFeginClient: debug

========================================================================================
Hystrix
服务提供方
@HystrixCommand
@EnableCircuitBreaker
@HystrixProperties

客户端
feign:
    hystrix:
        enable: true
@EnableHystrix
服务降级 fallback
服务熔断 CircuitBreaker
服务限流 limit


全局的DefaultProperties
@DefaultProperties(defaultFallback="xxx")
FeignFallBack